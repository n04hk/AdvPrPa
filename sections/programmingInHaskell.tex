%!TEX root = ../AdvPrPa.tex
\section{Programming in Haskell}
\begin{multicols}{2}
\subsection{First Steps}
\subsubsection{List functions}
\begin{tabularx}{\linewidth}{|X|X|}
  \hline
  \textbf{input} & \textbf{output} \\
  \hline
  \lstinline|head [1,2,3,4,5]| & \lstinline|1| \\
  \hline
  \lstinline|tail [1,2,3,4,5]| & \lstinline|[2,3,4,5]| \\
  \hline
  \lstinline|[1,2,3,4,5] !! 2| & \lstinline|3| \\
  \hline
  \lstinline|take 3 [1,2,3,4,5]| & \lstinline|[1,2,3]| \\
  \hline
  \lstinline|drop 3 [1,2,3,4,5]| & \lstinline|[4,5]| \\
  \hline
  \lstinline|length [1,2,3,4,5]| & \lstinline|5| \\
  \hline
  \lstinline|sum [1,2,3,4,5]| & \lstinline|15| \\
  \hline
  \lstinline|product [1,2,3,4,5]| & \lstinline|120| \\
  \hline
  \lstinline|[1,2,3] ++ [4,5]| & \lstinline|[1,2,3,4,5]| \\
  \hline
  \lstinline|reverse [1,2,3,4,5]| & \lstinline|[5,4,3,2,1]| \\
  \hline
\end{tabularx}

\subsubsection{Function Application}
In mathematics, function application is denoted using parentheses, and multiplication is often denoted using juxtaposition or space:\\
$f(a,b) + c d$\\
In Haskell, function application is denoted using space, and multiplication is denoted using $*$:\\
\lstinline{f a b + c*d}\\
Moreover, function application is assumed to have higher priority than all other operators:\\
\begin{tabularx}{\linewidth}{|X|X|}
  \hline
  \lstinline|f a + b| & \lstinline|(f a) + b|, \textbf{not} \lstinline|f(a + b)|\\
  \hline
\end{tabularx}

Examples:\\
\begin{tabularx}{\linewidth}{|X|X|}
\hline
\textbf{Mathematics} & \textbf{Haskell} \\
\hline
$f(x)$ & \lstinline|f x| \\
$f(x,y)$ & \lstinline|f x y| \\
$f(g(x))$ & \lstinline|f (g x)| \\
$f(x,g(y))$ & \lstinline|f x (g y)| \\
$f(x)g(y)$ & \lstinline|f x * g y| \\
\hline
\end{tabularx}

\subsubsection{Haskell Scripts}
\begin{itemize}
  \item As well as the functions in the standard library, you can also define your own functions
  \item New functions are defined within a script, a text file comprising a sequence of definitions
  \item By convention, Haskell scripts usually have a .hs suffix on their filename. This is not mandatory, but is useful for identification purposes.
\end{itemize}

\subsubsection{My First Script}
\begin{lstlisting}[multicols=2]
double x = x + x
quadruple x = double (double x)
factorial n = product [1..n]
average ns = sum ns `div` length ns
\end{lstlisting}
Note:
\begin{itemize}
  \item \lstinline{div} is enclosed in back quotes, not forward
  \item \lstinline{x 'f' y} is just syntactic sugar for \lstinline{f x y}.
\end{itemize}

To start up GHCi with the script, type the following in a terminal:
\begin{lstlisting}[language=bash]
$ ghci test.hs
\end{lstlisting}
Now both the standard library and the file test.hs are loaded, and functions from both can be used:
\begin{lstlisting}[language=bash]
> quadruple 10
40
> take (double 2) [1,2,3,4,5,6]
[1,2,3,4]
\end{lstlisting}
GHCi does not automatically detect that the script has been changed, so a \lstinline[language=bash]{reload} command must be executed before the new definitions can be used:
\begin{lstlisting}[language=bash]
> :reload
Reading file "test.hs"
\end{lstlisting}

\subsubsection{Useful GHCi Commands}
\begin{tabularx}{\linewidth}{|X|X|}
  \hline
  \textbf{Command} & \textbf{Meaning} \\
  \hline
  \lstinline[language=bash]|:load name| & load script \lstinline[language=bash]|name| \\
  \lstinline[language=bash]|:reload| & reload current script \\
  \lstinline[language=bash]|:set editor name| & set editor to \lstinline[language=bash]|name| \\
  \lstinline[language=bash]|:edit name| & edit script \lstinline[language=bash]|name| \\
  \lstinline[language=bash]|:edit| & edit current script \\
  \lstinline[language=bash]|:type expr| & show type of \lstinline[language=bash]|expr| \\
  \lstinline[language=bash]|:?| & show all commands \\
  \lstinline[language=bash]|:quit| & quit GHCi \\
  \hline
\end{tabularx}

\subsubsection{Naming Requirements}
\begin{itemize}
  \item Function and argument names must begin with a lower-case letter:\\
  \lstinline{myFun}, \lstinline{fun1}, \lstinline{arg_2}, \lstinline{x'}
  \item By convention, list arguments usually have an s suffix on their name:\\
  \lstinline{xs}, \lstinline{ns}, \lstinline{nss}
\end{itemize}
%TODO: somewhere around here needs a newpage to be placed to solve problem with multicols
\subsubsection{The Layout Rule}
In a sequence of definitions, each definition must begin in precisely the same column:
\begin{multicols}{3}
correct:
\begin{lstlisting}
a = 10
b = 20
c = 30
\end{lstlisting}
\vfill\null
\columnbreak
wrong:
\begin{lstlisting}
a = 10
 b = 20
c = 30
\end{lstlisting}
\vfill\null
\columnbreak
wrong:
\begin{lstlisting}
 a = 10
b = 20
 c = 30
\end{lstlisting}
\vfill\null
\end{multicols}
The layout rule avoids the need for explicit syntax to indicate the grouping of definitions.
\begin{multicols}{2}
implicit grouping:
\begin{lstlisting}
a = b + c
    where
      b = 1
      c = 2
d = a * 2
\end{lstlisting}
\vfill\null
\columnbreak
explicit grouping:
\begin{lstlisting}
a = b + c
    where
    {b = 1;
     c = 2}
d = a * 2
\end{lstlisting}
\vfill\null
\end{multicols}

\subsection{Types and Classes}
\subsubsection{What is a Type?}
A type is a name for a collection of related values.
For example, in Haskell the basic type \lstinline{Bool} contains the two logical values \lstinline{False} and \lstinline{True}.

\subsubsection{Type Errors}
Applying a function to one or more arguments of the wrong type is called a type error.
\begin{multicols}{2}
  \begin{lstlisting}
  > 1 + False
  error ...
  \end{lstlisting}
  \lstinline{1} is a number and \lstinline{False} is a logical value, but \lstinline{+} requires two numbers.
\end{multicols}

\subsubsection{Types in Haskell}
\begin{itemize}
  \item If evaluating an expression \lstinline{e} would produce a value of type \lstinline{t}, then \lstinline{e} has type \lstinline{t}, written \lstinline{e :: t}
  \item Every well formed expression has a type, which can be automatically calculated at compile time using a process called type inference.
  \item All type errors are found at compile time, which makes programs safer and faster by removing the need for type checks at runtime.
  \item In GHCi, the \lstinline{:type} command calculates the type of an expression, without evaluating it:
\begin{lstlisting}
> not False
True
> :type not False
not False :: Bool
\end{lstlisting}
\end{itemize}

\subsubsection{Basic Types}
Haskell has a number of basic types, including:
\begin{tabularx}{\linewidth}{|X|X|}
  \hline
  \lstinline|Bool| & logical values \\
  \hline
  \lstinline|Char| & single characters \\
  \hline
  \lstinline|String| & strings of characters \\
  \hline
  \lstinline|Int| & integer numbers \\
  \hline
  \lstinline|Float| & floating-point numbers \\
  \hline
\end{tabularx}

\subsubsection{List Types}
\begin{lstlisting}
[False,True,False] :: [Bool]
['a','b','c','d'] :: [Char]
\end{lstlisting}
In general: \lstinline{[t]} is the type of lists with elements of type \lstinline{t}.

Note:
\begin{itemize}
  \item The type of a list says nothing about its length:
\begin{lstlisting}
  [False,True] :: [Bool]
  [False,True,False] :: [Bool]
\end{lstlisting}
  \item The type of the elements is unrestricted. For example, we can have lists of lists:
\begin{lstlisting}
[['a'],['b','c']] :: [[Char]]
\end{lstlisting}
\end{itemize}

\subsubsection{Tuple Types}
\begin{lstlisting}
(False,True) :: (Bool,Bool)
(False,'a',True) :: (Bool,Char,Bool)
\end{lstlisting}
In general: \lstinline{(t1,t2,...,tn)} is the type of n-tuples whose ith components have type ti for any i in 1..n.

Note:
\begin{itemize}
  \item The type of a tuple encodes its size:
\begin{lstlisting}
(False,True) :: (Bool,Bool)
(False,True,False) :: (Bool,Bool,Bool)
\end{lstlisting}
  \item The type of the components is unrestricted:
\begin{lstlisting}
('a',(False,'b')) :: (Char,(Bool,Char))
(True,['a','b']) :: (Bool,[Char])
\end{lstlisting}
\end{itemize}

\subsubsection{Function Types}
A function is a mapping from values of one type to values of another type:
\begin{lstlisting}
not :: Bool -> Bool
even :: Int -> Bool
\end{lstlisting}
In general: \lstinline{t1 -> t2} is the type of functions that map values of type \lstinline{t1} to values of type \lstinline{t2}.

Note:
\begin{itemize}
  \item The arrow \lstinline{->} is typed at the keyboard as \lstinline{->}.
  \item The argument and result types are unrestricted. For example, functions with multiple arguments or results are possible using list or tuples:
\begin{lstlisting}
add :: (Int,Int) -> Int
add (x,y) = x+y
zeroto :: Int -> [Int]
zeroto n = [0..n]
\end{lstlisting}
\end{itemize}

\subsubsection{Curried Functions}
Functions with multiple arguments are also possible by returning functions as results:
\begin{lstlisting}
add' :: Int -> (Int -> Int)
add' x y = x+y
\end{lstlisting}
\lstinline{add'} takes an integer \lstinline{x} and returns a function \lstinline{add' x}. In turn, this function takes an integer \lstinline{y} and returns the result \lstinline{x+y}.

Note:
\begin{itemize}
  \item \lstinline{add} and \lstinline{add'} produce the same final result, but \lstinline{add} takes its two arguments at the same time, whereas \lstinline{add'} takes them one at a time:
\begin{lstlisting}
add :: (Int,Int) -> Int
add' :: Int -> (Int -> Int)
\end{lstlisting}
  \item Functions that take their arguments one at a time are called curried functions, celebrating the work of Haskell Curry on such functions.
  \item Functions with more than two arguments can be curried by returning nested functions:
\begin{lstlisting}
mult :: Int -> (Int -> (Int -> Int))
mult x y z = x*y*z
\end{lstlisting}
\end{itemize}
\lstinline{mult} takes an integer \lstinline{x} and returns a function \lstinline{mult x}, which in turn takes an integer \lstinline{y} and returns a function \lstinline{mult x y}, which finally takes an integer \lstinline{z} and returns the result \lstinline{x*y*z}.

\subsubsection{Why is Currying Useful?}
Curried functions are more flexible than functions on tuples, because useful functions can often be made by partially applying a curried function.\\
For example:
\begin{lstlisting}
add' 1 :: Int -> Int
take 5 :: [Int] -> [Int]
drop 5 :: [Int] -> [Int]
\end{lstlisting}

\subsubsection{Currying Conventions}
To avoid excess parantheses when using curried functions, two simple conventions are adopted:
\begin{itemize}
  \item The arrow \lstinline{->} associates to the right.\\
        \lstinline{Int -> Int -> Int -> Int}\\
        Means \lstinline{Int -> (Int -> (Int -> Int))}.
\item As a consequence, it is then natural for function application to associate to the left.
      \lstinline{mult x y z}\\
      Means \lstinline{((mult x) y) z}.\\
      Unless tupling is explicitly required, all functions in Haskell are normally defined in curried form.
\end{itemize}

\subsubsection{Polymorphic Functions}
A function is called polymorphic (''of many forms'') if its type contains one or more type variables.
\begin{lstlisting}
length :: [a] -> Int
\end{lstlisting}
For any type \lstinline{a}, \lstinline{length} takes a list of values of type \lstinline{a} and returns an integer.

Note:
\begin{itemize}
  \item Type variables can be instantiated to different types in different circumstances:
\begin{lstlisting}
> length [False,True] -- a = Bool
2
> length [1,2,3,4] -- a = Int
4
\end{lstlisting}
  \item Many of the functions defined in the standard prelude are polymorphic. For example:
\begin{lstlisting}
fst :: (a,b) -> a
head :: [a] -> a
take :: Int -> [a] -> [a]
zip :: [a] -> [b] -> [(a,b)]
id :: a -> a
\end{lstlisting}
\end{itemize}

\subsubsection{Overloaded Functions}
A polymorpic function is called overloaded if its type contains one or more class constraints.
\begin{lstlisting}
(+) :: Num a => a -> a -> a
\end{lstlisting}
For any numeric type \lstinline{a}, \lstinline{(+)} takes two values of type \lstinline{a} and returns a value of type \lstinline{a}.

Note:
\begin{itemize}
  \item Constrained type variables can be instantiated to any types that satisfy the constraints:
\begin{lstlisting}
> 1 + 2 -- a = Int
3
> 1.0 + 2.0 -- a = Float
3.0
> 'a' + 'b' -- Char is not a numeric type
ERROR
\end{lstlisting}
  \item Haskell has a number of type classes, including:
\begin{tabularx}{\linewidth}{|X|X|}
  \hline
  \lstinline|Num| & Numeric types \\
  \hline
  \lstinline|Eq| & Equality types \\
  \hline
  \lstinline|Ord| & Ordered types \\
  \hline
\end{tabularx}
  \item For example:
\begin{lstlisting}
(+) :: Num a => a -> a -> a
(==) :: Eq a => a -> a -> Bool
(<) :: Ord a => a -> a -> Bool
\end{lstlisting}
\end{itemize}

\subsubsection{Hints and Tips}
\begin{itemize}
  \item When defining a new function in Haskell, it is useful to begin by writing down its type;
  \item Within a script, it is good practice to state the type of every new function defined;
  \item When stating the types of polymorphic functions that use numbers, equality or orderings, take care to include the necessary class constraints.
\end{itemize}

\subsection{Defining Functions}
\subsubsection{Conditional Expressions}
As in most programming languages, functions can be defined using conditional expressions.
\begin{lstlisting}
abs :: Int -> Int
abs n = if n >= 0 then n else -n
\end{lstlisting} %TODO: insert proper greater-than-or-equal sign
\lstinline{abs} takes an integer \lstinline{n} and returns \lstinline{n} if it is non-negative and \lstinline{-n} otherwise.

Conditional expressions can be nested:
\begin{lstlisting}
signum :: Int -> Int
signum n = if n < 0 then -1 else
              if n == 0 then 0 else 1
\end{lstlisting}

Note:
\begin{itemize}
  \item In Haskell, conditional expressions must always have an \lstinline{else} branch, which avoids any possible ambiguity problems with nested conditionals.
\end{itemize}

\subsubsection{Guarded Equations}
As an alternative to conditionals, functions can also be defined using guarded equations.
\begin{lstlisting}
abs n | n >= 0    = n
      | otherwise = -n
\end{lstlisting}
As previously, but using guarded equations.

Guarded equations can be used to make definitions involving multiple conditions easier to read:
\begin{lstlisting}
signum n | n < 0     = -1
         | n == 0    = 0
         | otherwise = 1
\end{lstlisting}
Note:
\begin{itemize}
  \item The catch all condition \lstinline{otherwise} is defined in prelude by \lstinline{otherwise = True}.
\end{itemize}

\subsubsection{Pattern Matching}
Many functions have a particularly clear definition using pattern matching on their arguments.
\begin{lstlisting}
not :: Bool -> Bool
not False = True
not True  = False
\end{lstlisting}
\lstinline{not} maps \lstinline{False} to \lstinline{True}, and \lstinline{True} to \lstinline{False}.

Functions can often be defined in many different ways using pattern matching. For example:
\begin{lstlisting}
(&&) :: Bool -> Bool -> Bool
True  && True  = True
True  && False = False
False && True  = False
False && False = False
\end{lstlisting}
can be defined more compactly by
\begin{lstlisting}
True && True = True
_    && _    = False
\end{lstlisting}
However, the following definition is more efficient, because it avoids evaluating the second argument if the first argument is \lstinline{False}:
\begin{lstlisting}
True  && b = b
False && _ = False
\end{lstlisting}

Note:
\begin{itemize}
  \item The underscore symbol \lstinline{_} is a wildcard pattern that matches any argument value.
  \item Patterns are matched in order. For example, the following definition always returns \lstinline{False}:
\begin{lstlisting}
_    && _    = False
True && True = True
\end{lstlisting}
  \item Patterns may not repeat variables. For example, the following definition gives an error:
\begin{lstlisting}
b && b = b
_ && _ = False
\end{lstlisting}
\end{itemize}

\subsubsection{List Patterns}
Internally, every non-empty list is constructed by repeated use of an operator (:) called ''cons'' that adds an element to the start of the list.
\begin{lstlisting}
[1,2,3,4]
\end{lstlisting}
Means \lstinline{1:(2:(3:(4:[])))}.

Functions on lists can be defined using \lstinline{x:xa} patterns.
\begin{lstlisting}
head :: [a] -> a
head (x:_) = x
tail :: [a] -> [a]
tail (_:xs) = xs
\end{lstlisting}
\lstinline{head} and \lstinline{tail} map any non-empty list to its first and remaining elements.

Note:
\begin{itemize}
  \item \lstinline{x:xs} patterns only match non-empty lists:
\begin{lstlisting}
> head []
*** Exception: empty list
\end{lstlisting}
  \item \lstinline{x:xs} patterns must be parenthesised, because application has priority over \lstinline{(:)}. For example, the following definition gives an error:
\begin{lstlisting}
head x:_ = x
\end{lstlisting}
\end{itemize}

\subsubsection{Lambda expressions}
Functions can be constructed without naming the functions by using lampda expressions.
\begin{lstlisting}
\x -> x + x
\end{lstlisting}
Note:
\begin{itemize}
  \item The symbol $\lambda$ is the Greek letter lambda, and is typed at the keyboard as a backslash \textbackslash.
  \item In mathematics, nameless functions are usually denoted using the $\mapsto$ symbol, as in $x \mapsto x + x$.
  \item In Haskell, the use of the $\lambda$ symbol for nameless functions comes from the lambda calculus, the theory of functions on which Haskell is based.
\end{itemize}

\subsubsection{Why are Lambda's useful?}
Lambda expressions can be used to give a formal meaning to functions defined using currying.

For example:
\begin{lstlisting}
add x y = x + y
\end{lstlisting}
means
\begin{lstlisting}
add = \x -> (\y -> x + y)
\end{lstlisting}

Lambda expressions can be used to avoid naming functions that are only referenced once.

For example:
\begin{lstlisting}
odds n = map f [0..n-1]
         where
            f x = x*2 + 1
\end{lstlisting}
can be simplified to
\begin{lstlisting}
odds n = map (\x -> x*2 + 1) [0..n-1]
\end{lstlisting}

\subsubsection{Operator Sections}
An operator written between its two arguments can be converted into a curried function written before its two arguments by using parentheses.

For example:
\begin{lstlisting}
> 1 + 2
3
> (+) 1 2
3
\end{lstlisting}

This convention also allows one of the arguments of the operator to be included in the parentheses.

For example:
\begin{lstlisting}
> (1+) 2
3
> (+2) 1
3
\end{lstlisting}

In general, if $\oplus$ is an operator then functions of the form $(\oplus)$, $(x\oplus)$ and $(\oplus y)$ are called sections.

\subsubsection{Why are Sections useful?}
Useful functions can sometimes be constructed in a simple way using sections.

For example:
\begin{itemize}
  \item[\-] \lstinline{(1+)} - successor function
  \item[\-] \lstinline{(1/)} - reciprocation function
  \item[\-] \lstinline{(*2)} - doubling function
  \item[\-] \lstinline{(/2)} - halving function    
\end{itemize}

\subsection{List Comprehensions}
\subsubsection{Set Comprehensions}
In mathematics, the comprehension notation can be used to construct new sets from old sets.

$\{x^2 | x \in \{1...5\}\}$
The set $\{1,4,9,16,25\}$ of all numbers $x^2$ such that $x$ is an element of the set $\{1...5\}$.

\subsubsection{Lists Comprehensions}
In Haskell, a similar comprehension notation can be used to construct new lists from old lists.
\begin{lstlisting}
[x^2 | x <- [1..5]]
\end{lstlisting}
The list \lstinline{[1,4,9,16,25]} of all numbers \lstinline{x^2} such that \lstinline{x} is an element of the list \lstinline{[1..5]}.

Note:
\begin{itemize}
  \item The expression \lstinline{x <- [1..5]} is called a generator, as it states how to generate values for \lstinline{x}.
  \item Comprehensions can have multiple generators, separated by commas. For example:
\begin{lstlisting}
> [(x,y) | x <- [1,2,3], y <- [4,5]]
[(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
\end{lstlisting}
  \item Changing the order of the generators changes the order of the elements in the final list:
\begin{lstlisting}
> [(x,y) | y <- [4,5], x <- [1,2,3]]
[(1,4),(2,4),(3,4),(1,5),(2,5),(3,5)]
\end{lstlisting}
  \item Multiple generators are like nested loops, with later generators as more deeply nested loops whose variables change value more frequently.
  \item For example:
\begin{lstlisting}
> [(x,y) | y <- [4,5], x <- [1,2,3]]
[(1,4),(2,4),(3,4),(1,5),(2,5),(3,5)]
\end{lstlisting}
\lstinline{x <- [1,2,3]} is the last generator, so the value of the \lstinline{x} component of each pair changes most frequently.
\end{itemize}

\subsubsection{Dependant Generators}
Later generators can depend on the variables that are introduced by earlier generators.
\begin{lstlisting}
[(x,y) | x <- [1..3], y <- [x..3]]
\end{lstlisting}
The list \lstinline{[(1,1),(1,2),(1,3),(2,2),(2,3),(3,3)]} of all pairs of numbers \lstinline{(x,y,)} such that $x$,$y$ are elements of the list \lstinline{[1..3]} and $y \geq x$.

Using a dependant generator we can define the library function that concatenates a list of lists:
\begin{lstlisting}
concat :: [[a]] -> [a]
concat xss = [x | xs <- xss, x <- xs]
\end{lstlisting}

For example:
\begin{lstlisting}
> concat [[1,2,3],[4,5],[6]]
[1,2,3,4,5,6]
\end{lstlisting}

\subsubsection{Guards}
List comprehensions can use guards to restrict the values produced by earlier generators.
\begin{lstlisting}
[x | <- [1..10], even x]
\end{lstlisting}
The list \lstinline{[2,4,6,8,10]} of all numbers \lstinline{x} such that \lstinline{x} is an element of the list \lstinline{[1..10]} and \lstinline{x} is even.

Using a guard we can define a function that maps a positive integer to its list of factors:
\begin{lstlisting}
factors :: Int -> [Int]
factors n = 
    [x | y <- [1..n], n `mod` x == 0]
\end{lstlisting}

For example:
\begin{lstlisting}
> factors 15
[1,3,5,15]
\end{lstlisting}

A positive integer is prime if its only factors are 1 and itself.
Hence, using factors we can define a function that decides if a number is prime:
\begin{lstlisting}
prime :: Int -> Bool
prime n = factors n == [1,n]
\end{lstlisting}

For example:
\begin{lstlisting}
> prime 15
False
> prime 7
True
\end{lstlisting}

Using a guard we can now define a function that returns the list of all primes up to a given limit:
\begin{lstlisting}
primes :: Int -> [Int]
primes n = [x | x <- [2..n], prime x]
\end{lstlisting}

For example:
\begin{lstlisting}
> primes 40
[2,3,5,7,11,13,17,19,23,29,31,37]
\end{lstlisting}

\subsubsection{The Zip Function}
A useful library function is zip, which maps two lists to a list of pairs of their corresponding elements.
\begin{lstlisting}
zip :: [a] -> [b] -> [(a,b)]
\end{lstlisting}

For example:
\begin{lstlisting}
> zip ['a','b','c'] [1,2,3,4]
[('a',1),('b',2),('c',3)]
\end{lstlisting}

Using zip we can define a function returns that the list of all pairs of adjacent elements from a list:
\begin{lstlisting}
pairs :: [a] -> [(a,a)]
pairs xs = zip xs (tail xs)
\end{lstlisting}

For example:
\begin{lstlisting}
> pairs [1,2,3,4]
[(1,2),(2,3),(3,4)]
\end{lstlisting}

Using pairs we can define such a function that decides if the elements in a list are sorted:
\begin{lstlisting}
sorted :: Ord a => [a] -> Bool
sorted xs = and [x <= y | (x,y) <- pairs xs]
\end{lstlisting}

For example:
\begin{lstlisting}
> sorted [1,2,3,4]
True
> sorted [1,3,2,4]
False
\end{lstlisting}

Using zip we can define a function that returns the list of all positions of a value in a list:
\begin{lstlisting}
positions :: Eq a => a -> [a] -> [Int]
positions x xs = 
  [i | (x',i) <- zip xs [0..], x == x']
\end{lstlisting}

For example:
\begin{lstlisting}
> positions 0 [1,0,0,1,0,1,1,0]
[1,2,4,7]
\end{lstlisting}

\subsubsection{String Comprehensions}
A string is a sequence of characters enclosed in double quotes.
Internally, however, strings are represented as lists of characters.
\begin{lstlisting}
"abc" :: String
\end{lstlisting}
Means \lstinline{['a','b','c'] :: [Char]}.

Because strings are just special kinds of lists, any polymorphic function that operates on lists can also be applied to strings.
For example:
\begin{lstlisting}
> length "abcde"
5
> take 3 "abcde"
"abc"
> zip "abc" [1,2,3,4]
[('a',1),('b',2),('c',3)]
\end{lstlisting}

Similarly, list comprehensions can also be used to define functions on strings, such as counting how many times a character occurs in a string:
\begin{lstlisting}
count :: Char -> String -> Int
count x xs = length [x' | x' <- xs, x == x']
\end{lstlisting}

For example:
\begin{lstlisting}
> count 's' "Mississippi"
4
\end{lstlisting}

\subsection{Recursive Functions}
\subsubsection{Introduction}
As we have seen, many functions can naturally be defined in terms of other functions.
\begin{lstlisting}
fac :: Int -> Int
fac n = product [1..n]
\end{lstlisting}
\lstinline{fac} maps any integer \lstinline{n} to the product of the integers between \lstinline{1} and \lstinline{n}.

Expressions are evaluated by a stepwise process of applying functions to their arguments.

For example:
\begin{lstlisting}
fac 4
=
product [1..4]
=
product [1,2,3,4]
=
1*2*3*4
=
24
\end{lstlisting}

\subsubsection{Recursive Functions}
In Haskell, functions can also be defined in terms of themselves.
Such functions are called recursive.
\begin{lstlisting}
fac 0 = 1
fac n = n * fac (n-1)
\end{lstlisting}
\lstinline{fac} maps \lstinline{0} to \lstinline{1}, and any other integer to the product of itself and the factorial of its predecessor.

For example:
\begin{lstlisting}
fac 3
=
3 * fac 2
=
3 * (2 * fac 1)
=
3 * (2 * (1 * fac 0))
=
3 * (2 * (1 * 1))
=
3 * (2 * 1)
=
3 * 2
=
6
\end{lstlisting}

Note:
\begin{itemize}
  \item \lstinline{fac 0 = 1} is appropriate because \lstinline{1} is the identity for multiplication: \lstinline{1*x = x = x*1}.
  \item The recursive definition diverges on integers $< 0$ because the base case is never reached:
\begin{lstlisting}
> fac (-1)
*** Exception: stack overflow
\end{lstlisting}
\end{itemize}

\subsubsection{Why is Recursion useful?}
\begin{itemize}
  \item Some functions, such as \lstinline{factorial}, are simpler to define in terms of other functions.
  \item As we shall see, however, many functions can naturally be defined in terms of themselves.
  \item Properties of functions defined using recursion can be proved using the simple but powerful mathematical technique of induction.
\end{itemize}

\subsubsection{Recursion on Lists}
Recursion is not restricted to numbers, but can also be used to define functions on lists.
\begin{lstlisting}
product :: Num a => [a] -> a
product []     = 1
product (n:ns) = n * product ns
\end{lstlisting}
\lstinline{product} maps the empty list to \lstinline{1}, and any non-empty list to its head multiplied by the product of its tail.

For example:
\begin{lstlisting}
product [2,3,4]
=
2 * product [3,4]
=
2 * (3 * product [4])
=
2 * (3 * (4 * product []))
=
2 * (3 * (4 * 1))
=
24
\end{lstlisting}

Using the same pattern of recursion as in product we can define the \lstinline{length} function on lists.
\begin{lstlisting}
length :: [a] -> Int
length []     = 0
length (_:xs) = 1 + length xs
\end{lstlisting}
\lstinline{length} maps the empty list to \lstinline{0}, and any non-empty list to the successor of the length of its tail.

For example:
\begin{lstlisting}
length [1,2,3]
=
1 + length [2,3]
=
1 + (1 + length [3])
=
1 + (1 + (1 + length []))
=
1 + (1 + (1 + 0))
= 3
\end{lstlisting}

Using a similar pattern of recursion we can define the \lstinline{reverse} function on lists.
\begin{lstlisting}
reverse :: [a] -> [a]
reverse []     = []
reverse (x:xs) = reverse xs ++ [x]
\end{lstlisting}
\lstinline{reverse} maps the empty list to the empty list, and any non-empty list to the reverse of its tail appended to its head.

For example:
\begin{lstlisting}
reverse [1,2,3]
=
reverse [2,3] ++ [1]
=
(reverse [3] ++ [2]) ++ [1]
=
((reverse [] ++ [3]) ++ [2]) ++ [1]
=
(([] ++ [3]) ++ [2]) ++ [1]
=
[3,2,1]
\end{lstlisting}

\subsubsection{Multiple Arguments}
Functions with more than one argument can also be defined using recursion.
For example:
\begin{itemize}
  \item Zipping the elements of two lists:
\begin{lstlisting}
zip :: [a] -> [b] -> [(a,b)]
zip []     _      = []
Zip _      []     = []
zip (x:xs) (y:ys) = (x,y) : zip xs ys
\end{lstlisting}
  \item Remove the first \lstinline{n} elements from a list:
\begin{lstlisting}
drop :: Int -> [a] -> [a]
drop 0 xs     = xs
drop _ []     = []
drop n (_:xs) = drop (n-1) xs
\end{lstlisting}
  \item Appending two lists:
\begin{lstlisting}
(++) :: [a] -> [a] -> [a]
[]     ++ ys = ys
(x:xs) ++ ys = x : (xs ++ ys)
\end{lstlisting}
\end{itemize}

\subsubsection{Quicksort}
The quicksort algorithm for sorting a list of values can be specified by the following two rules:
\begin{itemize}
  \item The empty list is already sorted;
  \item Non-empty lists can be sorted by sorting the tail values $\leq$ the head, sorting the tail values $>$ the head, and then appending the resulting lists on either side of the head value.
\end{itemize}

Using recursion, this specification can be translated directly into an implementation:
\begin{lstlisting}
qsort :: Ord a => [a] -> [a]
qsort []     = []
qsort (x:xs) =
  qsort smaller ++ [x] ++ qsort larger
  where
    smaller = [a | a <- xs, a <= x]
    larger  = [b | b <- xs, b > x]
\end{lstlisting}

For example (abbreviating qsort as q):
%TODO: insert image


\subsection{Exercises:}

\subsubsection{Exercise 1}
\input{sections/exercise1}
\end{multicols}
\textbf{Programming Exercise: two-dimensional vectors}\\
\lstinputlisting{listings/exercises/AdvPrPa_Exer01Sol_V01.hs}
\newpage
\begin{multicols}{2}

\subsubsection{Exercise 2}
\input{sections/exercise2}
\end{multicols}
\textbf{Programming Exercise: List comprehensions}\\
\lstinputlisting{listings/exercises/AdvPrPa_Exer02Sol_V01.hs}
\newpage
\begin{multicols}{2}

\subsubsection{Exercise 3}
\input{sections/exercise3}
\end{multicols}
\textbf{Programming Exercise: Recursion over lists}\\
\lstinputlisting{listings/exercises/AdvPrPa_Exer03Sol_V01.hs}
\newpage
\begin{multicols}{2}

\subsubsection{Exercise 4}
\input{sections/exercise4}

\end{multicols}
\subsubsection{Exercise 7}
\lstinputlisting{listings/exercises/Exercise07Solution.hs}
\textbf{Higer-Order Functions: Types}\\
\begin{tabularx}{\linewidth}{|X|X|}
  \hline
  \lstinline|f01 = curry . fst| & \lstinline|((a, b1) -> c, b2) -> a -> b1 -> c|\\
  \hline
  \lstinline|f02 = uncurry . fst| & \lstinline|(a -> b1 -> c, b2) -> (a, b1) -> c|\\
  \hline
  \lstinline|f03 = fst . curry| & \textbf{Not correct.}\\
  \hline
  \lstinline|f04 = fst . uncurry| & \textbf{Not correct.}\\
  \hline
  \lstinline|f05 = curry . curry| & \lstinline|(((a, b1), b2) -> c) -> a -> b1 -> b2 -> c|\\
  \hline
  \lstinline|f06 map ($5)| & \lstinline|Num a => [a -> b] -> [b]|\\
  \hline
  \lstinline|v07 = map ($5) [(+1), (*2)| & \lstinline|Num b => [b]|\\
   & \lstinline|[6,10]|\\
  \hline
\end{tabularx}

\textbf{Programming Exercise: Higher-order function}\\
\lstinputlisting{listings/exercises/AdvPrPa_Exer04Sol_V01.hs}
\newpage

\subsubsection{Exercise 8}
\lstinputlisting{listings/exercises/Exercise08Solution.hs}

\subsubsection{Hutton Exercises}
\textbf{Hutton02}\\
\lstinputlisting{listings/exercises/HaskellHutton02.hs}
\textbf{Hutton03}\\
\lstinputlisting{listings/exercises/HaskellHutton03.hs}
\textbf{Hutton04}\\
\lstinputlisting{listings/exercises/HaskellHutton04.hs}
\textbf{Hutton05}\\
\lstinputlisting{listings/exercises/HaskellHutton05.hs}
\textbf{Hutton06}\\
\lstinputlisting{listings/exercises/HaskellHutton06.hs}

\textbf{Programming Exercises: Higher-order functions and recursion}\\
\lstinputlisting{listings/exercises/AdvPrPa_Exer05Sol_V01.hs}

