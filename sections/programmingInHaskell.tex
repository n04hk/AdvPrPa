%!TEX root = ../AdvPrPa.tex
\section{Programming in Haskell}
\begin{multicols}{2}
\subsection{First Steps}
\subsubsection{List functions}
\begin{tabularx}{\linewidth}{|X|X|}
  \hline
  \textbf{input} & \textbf{output} \\
  \hline
  \lstinline|head [1,2,3,4,5]| & \lstinline|1| \\
  \hline
  \lstinline|tail [1,2,3,4,5]| & \lstinline|[2,3,4,5]| \\
  \hline
  \lstinline|[1,2,3,4,5] !! 2| & \lstinline|3| \\
  \hline
  \lstinline|take 3 [1,2,3,4,5]| & \lstinline|[1,2,3]| \\
  \hline
  \lstinline|drop 3 [1,2,3,4,5]| & \lstinline|[4,5]| \\
  \hline
  \lstinline|length [1,2,3,4,5]| & \lstinline|5| \\
  \hline
  \lstinline|sum [1,2,3,4,5]| & \lstinline|15| \\
  \hline
  \lstinline|product [1,2,3,4,5]| & \lstinline|120| \\
  \hline
  \lstinline|[1,2,3] ++ [4,5]| & \lstinline|[1,2,3,4,5]| \\
  \hline
  \lstinline|reverse [1,2,3,4,5]| & \lstinline|[5,4,3,2,1]| \\
  \hline
\end{tabularx}

\subsubsection{Function Application}
In mathematics, function application is denoted using parentheses, and multiplication is often denoted using juxtaposition or space:\\
$f(a,b) + c d$\\
In Haskell, function application is denoted using space, and multiplication is denoted using $*$:\\
\lstinline{f a b + c*d}\\
Moreover, function application is assumed to have higher priority than all other operators:\\
\begin{tabularx}{\linewidth}{|X|X|}
  \hline
  \lstinline|f a + b| & \lstinline|(f a) + b|, \textbf{not} \lstinline|f(a + b)|\\
  \hline
\end{tabularx}

Examples:\\
\begin{tabularx}{\linewidth}{|X|X|}
\hline
\textbf{Mathematics} & \textbf{Haskell} \\
\hline
$f(x)$ & \lstinline|f x| \\
$f(x,y)$ & \lstinline|f x y| \\
$f(g(x))$ & \lstinline|f (g x)| \\
$f(x,g(y))$ & \lstinline|f x (g y)| \\
$f(x)g(y)$ & \lstinline|f x * g y| \\
\hline
\end{tabularx}

\subsubsection{Haskell Scripts}
\begin{itemize}
  \item As well as the functions in the standard library, you can also define your own functions
  \item New functions are defined within a script, a text file comprising a sequence of definitions
  \item By convention, Haskell scripts usually have a .hs suffix on their filename. This is not mandatory, but is useful for identification purposes.
\end{itemize}

\subsubsection{My First Script}
\lstinputlisting[multicols=2]{listings/test.hs}

Note:
\begin{itemize}
  \item \lstinline{div} is enclosed in back quotes, not forward
  \item \lstinline{x 'f' y} is just syntactic sugar for \lstinline{f x y}.
\end{itemize}

To start up GHCi with the script, type the following in a terminal:
\begin{lstlisting}[language=bash]
$ ghci test.hs
\end{lstlisting}
Now both the standard library and the file test.hs are loaded, and functions from both can be used:
\begin{lstlisting}[language=bash]
> quadruple 10
40
> take (double 2) [1,2,3,4,5,6]
[1,2,3,4]
\end{lstlisting}
GHCi does not automatically detect that the script has been changed, so a \lstinline[language=bash]{reload} command must be executed before the new definitions can be used:
\begin{lstlisting}[language=bash]
> :reload
Reading file "test.hs"
\end{lstlisting}

\subsubsection{Useful GHCi Commands}
\begin{tabularx}{\linewidth}{|X|X|}
  \hline
  \textbf{Command} & \textbf{Meaning} \\
  \hline
  \lstinline[language=bash]|:load name| & load script \lstinline[language=bash]|name| \\
  \lstinline[language=bash]|:reload| & reload current script \\
  \lstinline[language=bash]|:set editor name| & set editor to \lstinline[language=bash]|name| \\
  \lstinline[language=bash]|:edit name| & edit script \lstinline[language=bash]|name| \\
  \lstinline[language=bash]|:edit| & edit current script \\
  \lstinline[language=bash]|:type expr| & show type of \lstinline[language=bash]|expr| \\
  \lstinline[language=bash]|:?| & show all commands \\
  \lstinline[language=bash]|:quit| & quit GHCi \\
  \hline
\end{tabularx}

\subsubsection{Naming Requirements}
\begin{itemize}
  \item Function and argument names must begin with a lower-case letter:\\
  \lstinline{myFun}, \lstinline{fun1}, \lstinline{arg_2}, \lstinline{x'}
  \item By convention, list arguments usually have an s suffix on their name:\\
  \lstinline{xs}, \lstinline{ns}, \lstinline{nss}
\end{itemize}

\subsubsection{The Layout Rule}
In a sequence of definitions, each definition must begin in precisely the same column:
\begin{multicols}{3}
correct:
\begin{lstlisting}
a = 10
b = 20
c = 30
\end{lstlisting}
\vfill\null
\columnbreak
wrong:
\begin{lstlisting}
a = 10
 b = 20
c = 30
\end{lstlisting}
\vfill\null
\columnbreak
wrong:
\begin{lstlisting}
 a = 10
b = 20
 c = 30
\end{lstlisting}
\vfill\null
\end{multicols}
The layout rule avoids the need for explicit syntax to indicate the grouping of definitions.
\begin{multicols}{2}
implicit grouping:
\begin{lstlisting}
a = b + c
    where
      b = 1
      c = 2
d = a * 2
\end{lstlisting}
\vfill\null
\columnbreak
explicit grouping:
\begin{lstlisting}
a = b + c
    where
    {b = 1;
     c = 2}
d = a * 2
\end{lstlisting}
\vfill\null
\end{multicols}

\subsection{Types and Classes}
\subsubsection{What is a Type?}
A type is a name for a collection of related values.
For example, in Haskell the basic type \lstinline{Bool} contains the two logical values \lstinline{False} and \lstinline{True}.

\subsubsection{Type Errors}
Applying a function to one or more arguments of the wrong type is called a type error.
\begin{multicols}{2}
  \begin{lstlisting}
  > 1 + False
  error ...
  \end{lstlisting}
  \lstinline{1} is a number and \lstinline{False} is a logical value, but \lstinline{+} requires two numbers.
\end{multicols}

\subsubsection{Types in Haskell}
\begin{itemize}
  \item If evaluating an expression \lstinline{e} would produce a value of type \lstinline{t}, then \lstinline{e} has type \lstinline{t}, written \lstinline{e :: t}
  \item Every well formed expression has a type, which can be automatically calculated at compile time using a process called type inference.
  \item All type errors are found at compile time, which makes programs safer and faster by removing the need for type checks at runtime.
  \item In GHCi, the \lstinline{:type} command calculates the type of an expression, without evaluating it:
\begin{lstlisting}
> not False
True
> :type not False
not False :: Bool
\end{lstlisting}
\end{itemize}

\subsubsection{Basic Types}
Haskell has a number of basic types, including:
\begin{tabularx}{\linewidth}{|X|X|}
  \hline
  \lstinline|Bool| & logical values \\
  \hline
  \lstinline|Char| & single characters \\
  \hline
  \lstinline|String| & strings of characters \\
  \hline
  \lstinline|Int| & integer numbers \\
  \hline
  \lstinline|Float| & floating-point numbers \\
  \hline
\end{tabularx}

\subsubsection{List Types}
\begin{lstlisting}
[False,True,False] :: [Bool]
['a','b','c','d'] :: [Char]
\end{lstlisting}
In general: \lstinline{[t]} is the type of lists with elements of type \lstinline{t}.

Note:
\begin{itemize}
  \item The type of a list says nothing about its length:
\begin{lstlisting}
  [False,True] :: [Bool]
  [False,True,False] :: [Bool]
\end{lstlisting}
  \item The type of the elements is unrestricted. For example, we can have lists of lists:
\begin{lstlisting}
[['a'],['b','c']] :: [[Char]]
\end{lstlisting}
\end{itemize}

\subsubsection{Tuple Types}
\begin{lstlisting}
(False,True) :: (Bool,Bool)
(False,'a',True) :: (Bool,Char,Bool)
\end{lstlisting}
In general: \lstinline{(t1,t2,...,tn)} is the type of n-tuples whose ith components have type ti for any i in 1..n.

Note:
\begin{itemize}
  \item The type of a tuple encodes its size:
\begin{lstlisting}
(False,True) :: (Bool,Bool)
(False,True,False) :: (Bool,Bool,Bool)
\end{lstlisting}
  \item The type of the components is unrestricted:
\begin{lstlisting}
('a',(False,'b')) :: (Char,(Bool,Char))
(True,['a','b']) :: (Bool,[Char])
\end{lstlisting}
\end{itemize}

\subsubsection{Function Types}
A function is a mapping from values of one type to values of another type:
\begin{lstlisting}
not :: Bool -> Bool
even :: Int -> Bool
\end{lstlisting}
In general: \lstinline{t1 -> t2} is the type of functions that map values of type \lstinline{t1} to values of type \lstinline{t2}.

Note:
\begin{itemize}
  \item The arrow \lstinline{->} is typed at the keyboard as \lstinline{->}.
  \item The argument and result types are unrestricted. For example, functions with multiple arguments or results are possible using list or tuples:
\begin{lstlisting}
add :: (Int,Int) -> Int
add (x,y) = x+y
zeroto :: Int -> [Int]
zeroto n = [0..n]
\end{lstlisting}
\end{itemize}

\subsubsection{Curried Functions}
Functions with multiple arguments are also possible by returning functions as results:
\begin{lstlisting}
add' :: Int -> (Int -> Int)
add' x y = x+y
\end{lstlisting}
\lstinline{add'} takes an integer \lstinline{x} and returns a function \lstinline{add' x}. In turn, this function takes an integer \lstinline{y} and returns the result \lstinline{x+y}.

Note:
\begin{itemize}
  \item \lstinline{add} and \lstinline{add'} produce the same final result, but \lstinline{add} takes its two arguments at the same time, whereas \lstinline{add'} takes them one at a time:
\begin{lstlisting}
add :: (Int,Int) -> Int
add' :: Int -> (Int -> Int)
\end{lstlisting}
  \item Functions that take their arguments one at a time are called curried functions, celebrating the work of Haskell Curry on such functions.
  \item Functions with more than two arguments can be curried by returning nested functions:
\begin{lstlisting}
mult :: Int -> (Int -> (Int -> Int))
mult x y z = x*y*z
\end{lstlisting}
\end{itemize}
\lstinline{mult} takes an integer \lstinline{x} and returns a function \lstinline{mult x}, which in turn takes an integer \lstinline{y} and returns a function \lstinline{mult x y}, which finally takes an integer \lstinline{z} and returns the result \lstinline{x*y*z}.

\subsubsection{Why is Currying Useful?}
Curried functions are more flexible than functions on tuples, because useful functions can often be made by partially applying a curried function.\\
For example:
\begin{lstlisting}
add' 1 :: Int -> Int
take 5 :: [Int] -> [Int]
drop 5 :: [Int] -> [Int]
\end{lstlisting}

\subsubsection{Currying Conventions}
To avoid excess parantheses when using curried functions, two simple conventions are adopted:
\begin{itemize}
  \item The arrow \lstinline{->} associates to the right.\\
        \lstinline{Int -> Int -> Int -> Int}\\
        Means \lstinline{Int -> (Int -> (Int -> Int))}.
\item As a consequence, it is then natural for function application to associate to the left.
      \lstinline{mult x y z}\\
      Means \lstinline{((mult x) y) z}.\\
      Unless tupling is explicitly required, all functions in Haskell are normally defined in curried form.
\end{itemize}

\subsubsection{Polymorphic Functions}
A function is called polymorphic (''of many forms'') if its type contains one or more type variables.
\begin{lstlisting}
length :: [a] -> Int
\end{lstlisting}
For any type \lstinline{a}, \lstinline{length} takes a list of values of type \lstinline{a} and returns an integer.

Note:
\begin{itemize}
  \item Type variables can be instantiated to different types in different circumstances:
\begin{lstlisting}
> length [False,True] -- a = Bool
2
> length [1,2,3,4] -- a = Int
4
\end{lstlisting}
  \item Many of the functions defined in the standard prelude are polymorphic. For example:
\begin{lstlisting}
fst :: (a,b) -> a
head :: [a] -> a
take :: Int -> [a] -> [a]
zip :: [a] -> [b] -> [(a,b)]
id :: a -> a
\end{lstlisting}
\end{itemize}

\subsubsection{Overloaded Functions}
A polymorpic function is called overloaded if its type contains one or more class constraints.
\begin{lstlisting}
(+) :: Num a => a -> a -> a
\end{lstlisting}
For any numeric type \lstinline{a}, \lstinline{(+)} takes two values of type \lstinline{a} and returns a value of type \lstinline{a}.

Note:
\begin{itemize}
  \item Constrained type variables can be instantiated to any types that satisfy the constraints:
\begin{lstlisting}
> 1 + 2 -- a = Int
3
> 1.0 + 2.0 -- a = Float
3.0
> 'a' + 'b' -- Char is not a numeric type
ERROR
\end{lstlisting}
  \item Haskell has a number of type classes, including:
\begin{tabularx}{\linewidth}{|X|X|}
  \hline
  \lstinline|Num| & Numeric types \\
  \hline
  \lstinline|Eq| & Equality types \\
  \hline
  \lstinline|Ord| & Ordered types \\
  \hline
\end{tabularx}
  \item For example:
\begin{lstlisting}
(+) :: Num a => a -> a -> a
(==) :: Eq a => a -> a -> Bool
(<) :: Ord a => a -> a -> Bool
\end{lstlisting}
\end{itemize}

\subsubsection{Hints and Tips}
\begin{itemize}
  \item When defining a new function in Haskell, it is useful to begin by writing down its type;
  \item Within a script, it is good practice to state the type of every new function defined;
  \item When stating the types of polymorphic functions that use numbers, equality or orderings, take care to include the necessary class constraints.
\end{itemize}

\subsection{Defining Functions}
\subsubsection{Conditional Expressions}
As in most programming languages, functions can be defined using conditional expressions.
\begin{lstlisting}
abs :: Int -> Int
abs n = if n >= 0 then n else -n
\end{lstlisting} %TODO: insert proper greater-than-or-equal sign
\lstinline{abs} takes an integer \lstinline{n} and returns \lstinline{n} if it is non-negative and \lstinline{-n} otherwise.

Conditional expressions can be nested:
\begin{lstlisting}
signum :: Int -> Int
signum n = if n < 0 then -1 else
              if n == 0 then 0 else 1
\end{lstlisting}

Note:
\begin{itemize}
  \item In Haskell, conditional expressions must always have an \lstinline{else} branch, which avoids any possible ambiguity problems with nested conditionals.
\end{itemize}

\subsubsection{Guarded Equations}
As an alternative to conditionals, functions can also be defined using guarded equations.
\begin{lstlisting}
abs n | n >= 0    = n
      | otherwise = -n
\end{lstlisting}
As previously, but using guarded equations.

Guarded equations can be used to make definitions involving multiple conditions easier to read:
\begin{lstlisting}
signum n | n < 0     = -1
         | n == 0    = 0
         | otherwise = 1
\end{lstlisting}
Note:
\begin{itemize}
  \item The catch all condition \lstinline{otherwise} is defined in prelude by \lstinline{otherwise = True}.
\end{itemize}

\subsubsection{Pattern Matching}
Many functions have a particularly clear definition using pattern matching on their arguments.
\begin{lstlisting}
not :: Bool -> Bool
not False = True
not True  = False
\end{lstlisting}
\lstinline{not} maps \lstinline{False} to \lstinline{True}, and \lstinline{True} to \lstinline{False}.

Functions can often be defined in many different ways using pattern matching. For example:
\begin{lstlisting}
(&&) :: Bool -> Bool -> Bool
True  && True  = True
True  && False = False
False && True  = False
False && False = False
\end{lstlisting}
can be defined more compactly by
\begin{lstlisting}
True && True = True
_    && _    = False
\end{lstlisting}
However, the following definition is more efficient, because it avoids evaluating the second argument if the first argument is \lstinline{False}:
\begin{lstlisting}
True  && b = b
False && _ = False
\end{lstlisting}

Note:
\begin{itemize}
  \item The underscore symbol \lstinline{_} is a wildcard pattern that matches any argument value.
  \item Patterns are matched in order. For example, the following definition always returns \lstinline{False}:
\begin{lstlisting}
_    && _    = False
True && True = True
\end{lstlisting}
  \item Patterns may not repeat variables. For example, the following definition gives an error:
\begin{lstlisting}
b && b = b
_ && _ = False
\end{lstlisting}
\end{itemize}

\subsubsection{List Patterns}


\end{multicols}
